import { CLLocationManager, CLAuthorizationStatus, CLLocationManagerDelegate } from 'CoreLocation'
import { CaptiveNetwork, kCNNetworkInfoKeySSID, kCNNetworkInfoKeyBSSID } from 'SystemConfiguration.CaptiveNetwork';
import { NSArray, NSDictionary } from 'Foundation';
import { CFString } from 'CoreFoundation';
 

/**
 * 定义 接口参数
 */
type GetWifiInfoOptions = {
    success?: (res: object) => void;
    fail?: (res: object) => void;
    complete?: (res: object) => void;
};

class CurrentWifiInfo {
	
	wifiInterface: string = ""
	SSID: string = ""
	BSSID: string = ""
	
	constructor(wifiInterface: string, ssid: string, bssid: string) {
		this.wifiInterface = wifiInterface
		this.SSID = ssid
		this.BSSID = bssid
	}
}

class LocationPromiseService implements CLLocationManagerDelegate  {
	static promiseCompletionHandler: UTSCallback[] = []
	
	manager?: CLLocationManager
	
	constructor(manager?: CLLocationManager) {
		this.manager = manager
	}
	
	initlizeManager(): boolean {
		if (this.manager == null) {
			this.manager = new CLLocationManager()
			this.manager!.delegate = this
		}
		return true
	}
	
	locationManager(manager: CLLocationManager, status: CLAuthorizationStatus) {
		if (status == CLAuthorizationStatus.authorizedAlways || status == CLAuthorizationStatus.authorizedWhenInUse) {
			LocationPromiseService.promiseCompletionHandler.forEach((handler): void => {
				handler({success : true, message: "authorized success"})
			})
		} else if (status == CLAuthorizationStatus.notDetermined) { 
			manager.requestWhenInUseAuthorization()
		} else if (status == CLAuthorizationStatus.denied) {
			LocationPromiseService.promiseCompletionHandler.forEach((handler): void => {
				handler({success : false, message: "user denied"})
			})
		}
	}   
	
	locationManagerDidChangeAuthorization(manager: CLLocationManager) {
		
	}
	
	locationManagerDidPauseLocationUpdates(manager: CLLocationManager) {
		
	}
	
	locationManagerDidResumeLocationUpdates(manager: CLLocationManager) {
		
	}
	
	locationManagerShouldDisplayHeadingCalibration(manager: CLLocationManager): boolean {
		return true
	}
	
	requestPromise(completion: UTSCallback) {
		let status: CLAuthorizationStatus = CLLocationManager.authorizationStatus()
		if (status == CLAuthorizationStatus.notDetermined) {
			if (this.initlizeManager() == true) {
				this.manager!.requestWhenInUseAuthorization()
				LocationPromiseService.promiseCompletionHandler.push(completion)
			}
		} else if (status == CLAuthorizationStatus.authorizedAlways || status == CLAuthorizationStatus.authorizedWhenInUse) {
			completion({success : true, message: "authorized success"})
		} else if (status == CLAuthorizationStatus.denied) {
			if (CLLocationManager.locationServicesEnabled() == false && this.initlizeManager() == true) {
				this.manager!.requestWhenInUseAuthorization()
				LocationPromiseService.promiseCompletionHandler.push(completion)
			}
		} 
	}
}

const locationPromiseService: LocationPromiseService = new LocationPromiseService(null)



export function requestLocationPromise (completion: UTSCallback) {
	locationPromiseService.requestPromise(completion)
}

export function getCurrentWifiInfo (option: GetWifiInfoOptions) {
	let arr = CNCopySupportedInterfaces()
	if (arr != null) {
		let list = arr! as NSArray
		let index = 0
		let wifiInfo = new CurrentWifiInfo("", "", "")
		while (index < list.count) {
			let item = list[index]
			let interfaceName = item as string
			let dic = CNCopyCurrentNetworkInfo(interfaceName as CFString)
			if (dic != null) {
				let dict = dic! as NSDictionary
				let SSID = dict[kCNNetworkInfoKeySSID as string] 
				let BSSID = dict[kCNNetworkInfoKeyBSSID as string]
				
				if (SSID != null && BSSID != null) {
					let ssid = SSID! as string
					let bssid = BSSID! as string
					wifiInfo.wifiInterface = interfaceName
					wifiInfo.SSID = ssid
					wifiInfo.BSSID = bssid
					break;
				}
			}
			index++
		}
		
		if (wifiInfo.BSSID.length > 0 && wifiInfo.SSID.length > 0) {
			let res = {
				wifiInterface: wifiInfo.wifiInterface,
				SSID: wifiInfo.SSID,
				BSSID: wifiInfo.BSSID
			}
			option.success?.(res)
			option.complete?.(res)
		}else {
			option.fail?.({message: "current wifi is null"})
			option.complete?.({message: "current wifi is null"})
		}
	}else {
		option.fail?.({message: "current wifi is null"})
		option.complete?.({message: "current wifi is null"})
	}
}

