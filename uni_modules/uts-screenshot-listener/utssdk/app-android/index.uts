

import {
	getUniActivity
} from "io.dcloud.uts.android";


import ActivityCompat from "androidx.core.app.ActivityCompat";
import Manifest from "android.Manifest";
import PackageManager from "android.content.pm.PackageManager";
import Context from "android.content.Context";
import Point from "android.graphics.Point";
import Build from "android.os.Build";
import Handler from "android.os.Handler";
import MediaStore from "android.provider.MediaStore";
import Looper from "android.os.Looper";
import Cursor from "android.database.Cursor";
import ContentObserver from "android.database.ContentObserver";
import Uri from "android.net.Uri";
import BitmapFactory from "android.graphics.BitmapFactory";
import Locale from "java.util.Locale";
import WindowManager from "android.view.WindowManager";
import FileObserver from "android.os.FileObserver";
import File from "java.io.File";
import RequiresApi from "androidx.annotation.RequiresApi";
import Environment from "android.os.Environment";

/**
 * 读取媒体数据库时需要读取的列，其中 width、height 字段在 API 16 之后才有
 */
const MEDIA_PROJECTIONS_API_16 = arrayOf(
	"_data",
	MediaStore.Images.ImageColumns.DATE_TAKEN,
	MediaStore.Images.ImageColumns.WIDTH,
	MediaStore.Images.ImageColumns.HEIGHT
)

/**
 * 截屏路径判断的关键字
 */
const KEYWORDS = arrayOf(
	"screenshot", "screen_shot", "screen-shot", "screen shot",
	"screencapture", "screen_capture", "screen-capture", "screen capture",
	"screencap", "screen_cap", "screen-cap", "screen cap"
)



/**
 * android 10版本以上通过文件监听实现
 */
@RequiresApi(Build.VERSION_CODES.Q)
class ScreenFileObserver extends FileObserver {

	allScreen: File;

	constructor(screenFile: File) {
		super(screenFile)
		this.allScreen = screenFile;
		console.log(allScreen);
	}

	override onEvent(event: Int, path?: String): void {
		
		
		if (event == FileObserver.CREATE) {
			let newPath: string = new File(allScreen, path!).path;
			let currentTime = System.currentTimeMillis();

			if ((currentTime - lastFileObserverTime) < 1000) {
				// 本地截屏行为比上一次超过1000ms,才认为是一个有效的时间
				return;
			}
			
			console.log(path);
			lastFileObserverTime = System.currentTimeMillis()
			listenOption.onImageCatchChange(newPath)
		}
	}
}


/**
 * 屏幕尺寸
 */
let mScreenRealSize: Point | null = getRealScreenSize();
let mHasCallbackPaths: ArrayList<string> = new ArrayList()
let mStartListenTime: number = 0;
let mUiHandler: Handler = Handler(Looper.getMainLooper())
/**
 * 内部媒体文件监听器
 */
let mInternalObserver: MediaContentObserver | null = null;
/**
 * 外部媒体文件监听器
 */
let mExternalObserver: MediaContentObserver | null = null;
/**
 * android 10 版本使用的文件监听器
 */
let screenOB: ScreenFileObserver | null = null;

type onImageCatchOptions = {
	onImageCatchChange: (res: string) => void;
};

let listenOption: onImageCatchOptions = new onImageCatchOptions();

let lastFileObserverTime: number = 0;

/**
 * 处理媒体数据库的内容改变
 */
function handleMediaContentChange(contentUri: Uri) {
	let cursor: Cursor | null = null;
	try {
		cursor = getUniActivity()!.contentResolver.query(
			contentUri,
			MEDIA_PROJECTIONS_API_16,
			null, null,
			MediaStore.Images.ImageColumns.DATE_ADDED + " desc limit 1"
		)

		if (cursor == null) {
			return
		}

		if (!cursor.moveToFirst()) {
			return
		}

		// 获取各列的索引
		let dataIndex = cursor.getColumnIndex("_data")
		let dateTakenIndex = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATE_TAKEN)
		let widthIndex = cursor.getColumnIndex(MediaStore.Images.ImageColumns.WIDTH)
		let heightIndex = cursor.getColumnIndex(MediaStore.Images.ImageColumns.HEIGHT)

		// 获取行数据
		let data = cursor.getString(dataIndex)
		let dateTaken = cursor.getLong(dateTakenIndex)
		let width:number;
		let height:number;
		if (widthIndex >= 0 && heightIndex >= 0) {
			width = cursor.getInt(widthIndex)
			height = cursor.getInt(heightIndex)
		} else {
			let size = getImageSize(data)
			width = size.x
			height = size.y
		}

		// 处理获取到的第一行数据
		handleMediaRowData(data, dateTaken, width, height)
	} catch (e) {
		e.printStackTrace()
	} finally {
		if (cursor != null && !cursor.isClosed) {
			cursor.close()
		}
	}
}

/**
 * 获取媒体库内置图像的大小
 */
function getImageSize(imagePath: string): Point{
	let options = BitmapFactory.Options()
	options.inJustDecodeBounds = true
	BitmapFactory.decodeFile(imagePath, options)
	return Point(options.outWidth, options.outHeight)
}

/**
 * 处理获取到的一行数据
 */
function handleMediaRowData(data: String, dateTaken: Long, width: Int, height: Int) {

	if (checkScreenShot(data, dateTaken, width, height)) {
		if (!checkCallback(data)) {
			listenOption.onImageCatchChange(data)
		}
	} else {
		// 如果在观察区间媒体数据库有数据改变，又不符合截屏规则
	}
}

/**
 * 判断指定的数据行是否符合截屏条件
 */
function checkScreenShot(data?: string, dateTaken: Long, width: Int, height: Int): boolean {
	// 判断依据一: 时间判断
	// 如果加入数据库的时间在开始监听之前, 或者与当前时间相差大于10秒, 则认为当前没有截屏
	if (dateTaken < mStartListenTime || System.currentTimeMillis() - dateTaken > 10 * 1000) {
		return false
	}

	// 判断依据二: 尺寸判断
	if (mScreenRealSize != null) {
		// 如果图片尺寸超出屏幕, 则认为当前没有截屏
		if (!(width <= mScreenRealSize!.x && height <= mScreenRealSize!.y)
			|| (height <= mScreenRealSize!.x && width <= mScreenRealSize!.y)
		) {
			return false
		}
	}

	// 判断依据三: 路径判断
	if (data == null) {
		return false
	}

	let lowerData = data.lowercase(Locale.getDefault())
	// 判断图片路径是否含有指定的关键字之一, 如果有, 则认为当前截屏了
	for (keyWork in KEYWORDS) {
		if (lowerData.contains(keyWork)) {
			return true
		}
	}
	return false
}

/**
 * 判断是否已回调过, 某些手机ROM截屏一次会发出多次内容改变的通知; <br></br>
 * 删除一个图片也会发通知, 同时防止删除图片时误将上一张符合截屏规则的图片当做是当前截屏.
 */
function checkCallback(imagePath: String): boolean {

	if (mHasCallbackPaths.contains(imagePath)) {
		return true
	}
	// 大概缓存15~20条记录便可
	if (mHasCallbackPaths.size >= 20) {
		// for (i of 4) {
		// 	mHasCallbackPaths.removeAt(0)
		// }
	}
	mHasCallbackPaths.add(imagePath)
	return false
}

/**
 * 获取屏幕分辨率
 */
function getRealScreenSize(): Point | null {
	let screenSize: Point = Point();
	try {
		let windowManager = getUniActivity()!.getSystemService(Context.WINDOW_SERVICE) as WindowManager
		screenSize.x = windowManager.currentWindowMetrics.bounds.width();
		screenSize.y = windowManager.currentWindowMetrics.bounds.height();
		// let defaultDisplay = windowManager.defaultDisplay
		
		// let defaultDisplay =  getUniActivity()!.display
		// defaultDisplay!.getRealSize(screenSize)
		console.log(screenSize);
	} catch (e) {
		e.printStackTrace()
	}

	return screenSize
}



/**
 * 媒体内容观察者
 */
class MediaContentObserver extends ContentObserver {

	contentUri: Uri;
	handler: Handler;

	constructor(contentUri: Uri, handler: Handler) {
		super(handler)
		this.contentUri = contentUri
		this.handler = handler
	}

	override onChange(selfChange: Boolean) {
		super.onChange(selfChange)
		handleMediaContentChange(contentUri)
	}
}



/**
 * 请求权限
 */
export function requestPremission() {

	// 注册一个请求回调
	// 发起权限申请
	if (ActivityCompat.checkSelfPermission(getUniActivity()!, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
		ActivityCompat.requestPermissions(getUniActivity()!, arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE), 1001)
	}

	// 请求权限
	return { name: "requestPremission" };
}



/**
 * 开启截图监听
 */
export function onUserCaptureScreen(success: (res: string) => void) {
	listenOption.onImageCatchChange = success;
	
	console.log(Build.VERSION.SDK_INT);
	console.log(Build.VERSION_CODES.Q);

	if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
		// android 10 以上版本，使用监听文件的方式，更加可靠
		let directory_screenshot: File;

		// let directory_pictures = getUniActivity()!.getExternalFilesDir(Environment.DIRECTORY_PICTURES)
		// let directory_dcim = getUniActivity()!.getExternalFilesDir(Environment.DIRECTORY_DCIM)

		let directory_pictures = File(Environment.getExternalStorageDirectory(), Environment.DIRECTORY_PICTURES);
		let directory_dcim = File(Environment.getExternalStorageDirectory(), Environment.DIRECTORY_DCIM);
		
		console.log(directory_pictures);
		console.log(directory_dcim);
		
		// console.log(directory_pictures2);
		// console.log(directory_dcim2);
		
		if (Build.MANUFACTURER.equals("Xiaomi", true)) {
			directory_screenshot = File(directory_dcim, "Screenshots");
		} else {
			directory_screenshot = File(directory_pictures, "Screenshots");
		}
		if (screenOB != null) {
			screenOB!.stopWatching()
		}
		screenOB = new ScreenFileObserver(directory_screenshot)
		screenOB!.startWatching()
	} else {
		// android 10 以下版本，采用监听系统媒体库的方式
		mStartListenTime = System.currentTimeMillis()

		// 创建内容观察者
		mInternalObserver =
			new MediaContentObserver(MediaStore.Images.Media.INTERNAL_CONTENT_URI, mUiHandler)
		mExternalObserver =
			new MediaContentObserver(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, mUiHandler)

		// 注册内容观察者
		getUniActivity()!.getContentResolver()!.registerContentObserver(
			MediaStore.Images.Media.INTERNAL_CONTENT_URI,
			false,
			mInternalObserver!
		)
		getUniActivity()!.getContentResolver()!.registerContentObserver(
			MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
			false,
			mExternalObserver!
		)
	}

}

/**
 * 关闭截屏监听
 */
export function offUserCaptureScreen(success: (res: string) => void) {

	if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
		// android 10以上，关闭监听通过移除文件监听器实现
		if (screenOB != null) {
			screenOB!.stopWatching()
			screenOB = null
		}
		lastFileObserverTime = 0;
	} else {
		// android 10以下，注销内容观察者
		if (mInternalObserver != null) {
			try {
				getUniActivity()!.contentResolver.unregisterContentObserver(mInternalObserver!)
			} catch (e) {
				e.printStackTrace()
			}
			mInternalObserver = null
		}
		if (mExternalObserver != null) {
			try {
				getUniActivity()!.contentResolver.unregisterContentObserver(mExternalObserver!)
			} catch (e) {
				e.printStackTrace()
			}
			mExternalObserver = null
		}

		// 清空数据
		mStartListenTime = 0
	}
	success("");
}









